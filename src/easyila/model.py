from dataclasses import dataclass, field
import textwrap
from typing import List, Dict

import easyila.lynth.smt as smt

"""
An Instruction represents a sequence of state transitions. A transition is a mapping
of state variables to expressions computing their next values.

A single instruction is considered to be atomic.
"""
Instruction = List[Dict[smt.Variable, smt.Term]]

# models should look something like this?
# TODO instead of having separate uf/logic/next logic, should they all be values of
# a dict keyed by variables? probably not, because of the splitting behavior of the
# `instructions` array
@dataclass
class Model:
    name: str
    inputs: List[smt.Variable] = field(default_factory=list)
    outputs: List[smt.Variable] = field(default_factory=list)
    state: List[smt.Variable] = field(default_factory=list)
    # TODO variables are just UFs of 0 arity -- should we treat them all the same?
    ufs: List[smt.UFTerm] = field(default_factory=list)
    # memories: List[]
    # how do we incorporate child-ILA transitions? how do we connect modules?
    submodules: Dict[str, "Module"] = field(default_factory=dict)
    logic: Dict[smt.Variable, smt.Term] = field(default_factory=dict)
    """Same-cycle logic expressions."""

    """
    TODO

    should we be able to have multiple submodules of the same instance? this
    has a common use case for stuff like memories that are repeated

    how do we distinguish between having ILA instructions to execute vs.
    having transitions? for now, just have a default "NEXT" instruction
    """
    default_next: Instruction = field(default_factory=list)
    instructions: Dict[str, Instruction] = field(default_factory=dict)
    init_values: Dict[str, smt.BVConst] = field(default_factory=dict)

    def print(self):
        print(textwrap.dedent(f"""\
            Model(
                inputs={self.inputs},
                outputs={self.outputs},
                state={self.state},
                ufs={self.ufs},
                submodules={self.submodules},
                logic={self.logic},
                default_next={self.default_next},
                instructions={self.instructions},
                init_values={self.init_values},
            )
            """))

@dataclass
class ManualModel(Model):
    """
    An ILA model constructed by hand.
    """
    pass

class CaseSplitModel(Model):
    ...

@dataclass
class SyntaxGeneratedModel(Model):
    """
    A model generated by parsing a verilog file.

    State variables correspond to RTL registers, and transitions are
    automatically parsed.
    """
    def __init__(self, verilog_file):
        # TODO
        ...

@dataclass
class SynthesizedModel(Model):
    """
    A model with components generated by SyGuS.

    TODO figure out how to compose this
    """
    def __init__(self):
        ...
