from dataclasses import dataclass, field
import textwrap
from typing import List, Dict

import easyila.lynth.smt as smt

"""
An Instruction represents a sequence of state transitions. A transition is a mapping
of state variables to expressions computing their next values.

A single instruction is considered to be atomic.
"""
Instruction = List[Dict[smt.Variable, smt.Term]]

# models should look something like this?
# TODO instead of having separate uf/logic/next logic, should they all be values of
# a dict keyed by variables? probably not, because of the splitting behavior of the
# `instructions` array
@dataclass
class Model:
    name: str
    inputs: List[smt.Variable] = field(default_factory=list)
    outputs: List[smt.Variable] = field(default_factory=list)
    state: List[smt.Variable] = field(default_factory=list)
    # TODO variables are just UFs of 0 arity -- should we treat them all the same?
    ufs: List[smt.UFTerm] = field(default_factory=list)
    # memories: List[]
    # how do we incorporate child-ILA transitions? how do we connect modules?
    submodules: Dict[str, "Model"] = field(default_factory=dict)
    logic: Dict[smt.Variable, smt.Term] = field(default_factory=dict)
    """Same-cycle logic expressions."""

    """
    TODO

    should we be able to have multiple submodules of the same instance? this
    has a common use case for stuff like memories that are repeated

    how do we distinguish between having ILA instructions to execute vs.
    having transitions? for now, just have a default "NEXT" instruction
    """
    default_next: Instruction = field(default_factory=list)
    instructions: Dict[str, Instruction] = field(default_factory=dict)
    init_values: Dict[str, smt.BVConst] = field(default_factory=dict)

    def print(self):
        print(textwrap.dedent(f"""\
            Model(
                name="{self.name}",
                inputs={self.inputs},
                outputs={self.outputs},
                state={self.state},
                ufs={self.ufs},
                submodules={self.submodules},
                logic={self.logic},
                default_next={self.default_next},
                instructions={self.instructions},
                init_values={self.init_values},
            )
            """))

    def to_uclid(self):
        u_vars = []
        def u_append(lst, use_decl):
            nonlocal u_vars
            if len(lst) > 0:
                u_vars.extend((s.get_decl() if use_decl else s).to_uclid() for s in lst)
        u_append(self.inputs, True)
        u_append(self.outputs, True)
        u_append(self.state, True)
        u_append(self.ufs, False)
        u_vars = textwrap.indent("\n".join(u_vars), 4 * '    ')
        return textwrap.dedent(f"""\
            module {self.name} {{
{u_vars}

                init {{

                }}

                next {{

                }}
            }}
            """)

@dataclass
class ManualModel(Model):
    """
    An ILA model constructed by hand.
    """
    pass

class CaseSplitModel(Model):
    ...

@dataclass
class SyntaxGeneratedModel(Model):
    """
    A model generated by parsing a verilog file.

    State variables correspond to RTL registers, and transitions are
    automatically parsed.
    """
    def __init__(self, verilog_file):
        # TODO
        ...

@dataclass
class SynthesizedModel(Model):
    """
    A model with components generated by SyGuS.

    TODO figure out how to compose this
    """
    def __init__(self):
        ...
