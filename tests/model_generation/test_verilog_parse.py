
import textwrap
from typing import List, Optional

import pytest

import easyila.lynth.smt as smt
from easyila.verilog import verilog_to_model, COIConf
from easyila.model import Model

class TestVerilogParse:
    """
    Tests generation of Models from Verilog files.

    On the current version of pyverilog, initial register values are not treated properly, hence
    the need for a reset input.

    pyverilog if branches that are missing an else block also will produce a dummy "dest" variable
    when `tocode` is called, though this does not affect the actual dataflow graph.
    """

    def test_verilog_single_noimp(self):
        """
        Tests model generation of a model from a single RTL module.
        No "important" values are specified. "_rn" signals for intermediate values
        generated by pyverilog are kept.

        Rename inlining is off, meaning they should appear in the output.
        """
        rtl = textwrap.dedent("""\
            module top(input clk, input should_inc, output [2:0] result);
                reg [2:0] a;
                wire [2:0] a_p1;
                always @(posedge clk) begin
                    if (should_inc) begin
                        a = a_p1;
                    end
                end
                assign a_p1 = a + 3'h1;
                assign result = ~a;
            endmodule
            """
        )
        model = verilog_to_model(rtl, "top", inline_renames=False)
        model.print()
        bv3 = smt.BVSort(3)
        var = smt.Variable
        a = var("a", bv3)
        rn_a = var("_rn0_a", bv3)
        a_p1 = var("a_p1", bv3)
        should_inc = smt.BoolVariable("should_inc")
        assert model == \
            Model(
                "top",
                inputs=[should_inc],
                outputs=[var("result", bv3)],
                state=[a, a_p1, rn_a],
                logic={
                    a_p1: a + 1,
                    rn_a: a_p1,
                    var("result", bv3): ~a,
                },
                default_next=[{a: should_inc.ite(rn_a, a)}],
            )

    def test_verilog_always_star(self):
        """
        Tests that dependencies from always @* blocks are placed in the correct cycle.

        Also implicitly tests inlining of "rename" variables.
        """
        rtl = textwrap.dedent("""\
            module top(input clk, input in);
                reg r0;
                reg r1;
                always @(posedge clk) begin
                    r0 = r0 | in;
                end
                always @* begin
                    r1 = r1 | in;
                end
            endmodule
            """)
        model = verilog_to_model(rtl, "top", inline_renames=True)
        model.print()
        in_ = smt.BoolVariable("in")
        r0 = smt.BoolVariable("r0")
        r1 = smt.BoolVariable("r1")
        assert model == \
            Model(
                "top",
                inputs=[in_],
                state=[r0, r1],
                logic={r1: r1 | in_},
                default_next=[{r0: r0 | in_}]
            )

    def test_verilog_single_imp_no_parents(self):
        """
        Tests generation of a model from a single RTL module with specified important signals.
        `coi_conf` is NO_COI, meaning every important signal needs to be manually specified.
        """
        rtl = textwrap.dedent("""\
            module top(input clk, input should_inc, output [2:0] result);
                reg [2:0] a;
                reg [2:0] b;
                wire [2:0] a_p1;
                wire [2:0] b_p1;
                always @(posedge clk) begin
                    if (should_inc) begin
                        a = a_p1;
                        b = b_p1;
                    end
                end
                assign a_p1 = a + 3'h1;
                assign b_p1 = b + 3'h1;
                assign result = ~a | ~b;
            endmodule
            """)
        bv3 = smt.BVSort(3)
        var = smt.Variable
        # TODO to allow for composition of child modules, and specifying important_signals for those
        model_no_a = verilog_to_model(rtl, "top", important_signals=["should_inc", "b", "b_p1", "result"])
        model_no_a.print()
        a = var("a", bv3)
        a_p1 = var("a_p1", bv3)
        b = var("b", bv3)
        b_p1 = var("b_p1", bv3)
        should_inc = var("should_inc", smt.BoolSort())
        result = var("result", bv3)
        assert model_no_a == \
            Model(
                "top",
                inputs=[should_inc],
                outputs=[result],
                state=[b, b_p1],
                # `a` appears in the expression for `result`, but is not declared important
                # therefore, it is modeled as an uninterpreted function
                # TODO namespace collision for should_inc parameter?
                ufs=[smt.UFTerm("a", bv3, should_inc)],
                logic={
                    b_p1: b + 1,
                    result: (~a) | (~b)
                },
                instructions={
                    # TODO
                },
                init_values={}
            )
        model_no_b = verilog_to_model(rtl, "top", important_signals=["should_inc", "a", "a_p1", "result"])
        assert model_no_b == \
            Model(
                "top",
                inputs=[should_inc],
                outputs=[result],
                state=[a, a_p1],
                # `b` appears in the expression for `result`, but is not declared important
                # therefore, it is modeled as an uninterpreted function
                # TODO namespace collision for should_inc parameter?
                ufs=[smt.UFTerm("b", bv3, should_inc)],
                logic={
                    a_p1: a + 1,
                    result: (~a) | (~b)
                },
                instructions={
                    # TODO
                },
                init_values={}
            )

    def test_verilog_single_imp_with_parents(self):
        """
        Tests generation of a model from a single RTL module with specified important signals.
        `coi_conf` is UF_ARGS_COI, meaning some important signals should be inferred.
        """
        rtl = textwrap.dedent("""\
            module top(input clk, input should_inc, output [2:0] result);
                reg [2:0] a;
                reg [2:0] b;
                wire [2:0] a_p1;
                wire [2:0] b_p1;
                always @(posedge clk) begin
                    if (should_inc) begin
                        a = a_p1;
                        b = b_p1;
                    end
                end
                assign a_p1 = a + 3'h1;
                assign b_p1 = b + 3'h1;
                assign result = ~a | ~b;
            endmodule
            """)
        # TODO to allow for composition of child modules, and specifying important_signals for those
        model_no_a = verilog_to_model(rtl, "top", important_signals=["b"], coi_conf=COIConf.NO_COI)
        assert model_no_a == \
            Model(
            )
        model_no_b = verilog_to_model(rtl, "top", important_signals=["a"], coi_conf=COIConf.NO_COI)
        assert model_no_b == \
            Model(
            )

    def test_verilog_one_child_module(self):
        rtl = textwrap.dedent("""\
            module inner(input clk, input rst, input i_inner, output o_inner);
                reg [2:0] i_state;
                always @(posedge clk) begin
                    if (rst) begin
                        i_state = 3'h0;
                    end else begin
                        i_state = i_inner | i_state;
                    end
                end
                assign o_inner = i_state[0];
            endmodule

            module top(input clk, input rst, input i_top, output reg o_top);
                reg i_top_last;
                wire i_out_next;
                inner sub(
                    .clk(clk),
                    .rst(rst),
                    .i_inner(i_top_last),
                    .o_inner(i_out_next)
                );
                always @(posedge clk) begin
                    i_top_last = i_top;
                    o_top = i_out_next;
                end
            endmodule
            """
        )
        model = verilog_to_model(rtl, "top")
        assert False